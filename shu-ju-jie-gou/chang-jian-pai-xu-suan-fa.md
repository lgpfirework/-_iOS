![](http://img.blog.csdn.net/20160507223620928?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

![](http://img.blog.csdn.net/20160507223606635?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

#### 冒泡排序（BubbleSort）

       冒泡排序（BubbleSort）是一种简单的排序算法。它重复地遍历过要排序的数列，一次比较两个元素，如果他们的顺序错误把他们交换过来。遍历数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。

冒泡排序算法的步骤：

      1.比较相邻的元素。如果第一个比第二个大，就交换他们两个。

      2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。

      3.针对所有的元素重复以上的步骤，除了最后一个。

      4.持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

#### 选择排序\(SelectSort\)

       选择排序\(SelecSort\)是一种简单直观的排序算法。它的工作原理如下：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。简单选择排序算法改进

       传统的简单选择排序,每趟循环只能确定一个元素排序后的定位。我们可以考虑改进为每趟循环确定两个元素\(当前趟最大和最小记录\)的位置,从而减少排序所需的循环次数。改进后对n个数据进行排序,最多只需进行\[n/2\]趟循环即可。

#### 快速排序（QuickSort）

       快速排序是冒泡排序的一种改进，冒泡排序排完一趟是最大值冒出来了，那么可不可以先选定一个值，然后扫描待排序序列，把小于该值的记录和大于该值的记录分成两个单独的序列，然后分别对这两个序列进行上述操作。这就是快速排序，我们把选定的那个值称为枢纽值，如果枢纽值为序列中的最大值，那么一趟快速排序就变成了一趟冒泡排序。

快速排序算法的步骤：

       1.从数列中挑出一个元素，称为 "基准"，重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。

       2.递归地把小于基准值元素的子数列和大于基准值元素的子数列排序。

       3.递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。

#### 插入排序（InsertSort）

       插入排序就是每一步都将一个待排数据按其大小插入到已经排序的数据中的适当位置，直到全部插入完毕。 插入排序方法分直接插入排序和折半插入排序两种。

#### 希尔排序（ShellSort）

       希尔排序（ShellSort）又称为“缩小增量排序”。该方法的基本思想是：先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。因为直接插入排序在元素基本有序的情况下（接近最好情况），效率是很高的，因此希尔排序在时间效率上比前两种方法有较大提高。

希尔排序是基于插入排序的以下两点性质而提出改进方法的：

       1.插入排序在对几乎已经排好序的数据操作时， 效率高， 即可以达到线性排序的效率。

       2.插入排序一般来说是低效的， 因为插入排序每次只能将数据移动一位，步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。

#### 堆排序（HeapSort）

        移除位在第一个数据的根结点，并做最大堆调整的递归运算。

堆的存储

        一般都用数组来表示堆，i结点的父结点下标就为\(i – 1\) / 2。它的左右子结点下标分别为2 \* i + 1和2 \* i + 2。

#### 归并排序（MergeSort）算法

        归并排序（MergeSort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法的一个非常典型的应用。

归并排序的步骤如下：

        1. 把长度为n的输入序列分成两个长度为n/2的子序列。

        2. 对这两个子序列分别采用递归归并排序。

        3. 将两个排序好的子序列递归合并成一个最终的排序序列。

#### 基数排序\(RadixSort\)

       基数排序\(RadixSort\)是对桶排序的改进和推广。唯一的区别是基数排序强调多关键字，而桶排序没有这个概念，换句话说基数排序对每一种关键字都进行桶排序，而桶排序同一个桶内排序可以任意或直接排好序。基数排序的方式可以采用LSD或MSD，LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。

基数排序的基本思想是：从低位到高位依次对Kj\(j=d-1，d-2，…，0\)进行箱排序。

#### 计数排序\(CountSort\)

       计数排序\(CountSort\)是一种稳定的排序算法，和基数排序一样都是桶排序的变体。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值小于等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。

计数排序的原理

       设被排序的数组为A,排序后存储到B，C为临时数组。所谓计数，首先是通过一个数组C\[i\]计算大小等于i的元素个数，此过程需要一次循环遍历就可以；在此基础上，计算小于或者等于i的元素个数，也是一重循环就完成。下一步是关键：逆序循环，length\[A\]到1，将A\[i\]放到B中第C\[A\[i\]\]个位置上。原理是：C\[A\[i\]\]表示小于等于a\[i\]的元素个数，正好是A\[i\]排序后应该在的位置。而且从length\[A\]到1逆序循环，可以保证相同元素间的相对顺序不变，这也是计数排序稳定性的体现。在数组A有附件属性的时候，稳定性是非常重要的。

