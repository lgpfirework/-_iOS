#### 1.runtime如何实现weak属性？

首先weak属性表示的是一种非拥有关系，在为weak属性设置新值时，既不保留新值，也不释放旧值；

weak的底层runtime实现原理就是内存中会有一个哈希表去存储所有weak对象，将weak指向的对象的内存地址（比如a）作为key，当weak对象的引用计数为0的时候，在此表中找到所有的以a为key的weak引用对象并将其置为nil

### 2.runtime如何通过selector找到对应的IMP地址？

* 对象方法列表是存放在isa指针指向的类对象中的；
* 类方法列表是存放在isa指针指向的元类对象中的；
* 方法列表（哈希表）中每个方法结构体中记录着**方法名，方法实现，参数类型等，**selector的本质就是方法名，通过方法名就可以在方法列表中找到对应的方法实现。

#### 3. \_objc\_msgForward函数是做什么的？直接调用它将会发生什么？

消息转发。当向一个对象发送一个对象没有实现的消息时，\_objc\_msgForward会尝试做消息转发。

直接调用是非常危险的，是一把双刃刀，用不好就是crash，JSPatch用到了这个

#### 4.OC调用方法的过程

OC是动态进行时语言，每个方法在运行时都会被动态转为消息发送，即objc\_msgSend\(\);

过程如下：

\* objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类 

\* 然后在该类中的方法列表以及其父类方法列表中寻找方法运行

 \* 如果，在最顶层的父类（一般也就NSObject）中依然找不到相应的方法时，程序在运行时会挂掉并抛出异常unrecognized selector sent to XXX 

\* 但是在这之前，objc的运行时会给出三次拯救程序崩溃的机会





